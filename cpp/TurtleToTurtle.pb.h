// Copyright (c) 2018, The TurtleCoin Developers
// 
// Please see the included LICENSE file for more information.

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TurtleToTurtle.proto

#ifndef PROTOBUF_INCLUDED_TurtleToTurtle_2eproto
#define PROTOBUF_INCLUDED_TurtleToTurtle_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "TurtleCoin.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_TurtleToTurtle_2eproto 

namespace protobuf_TurtleToTurtle_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_TurtleToTurtle_2eproto
namespace TurtleToTurtle {
class BlockChainPayload;
class BlockChainPayloadDefaultTypeInternal;
extern BlockChainPayloadDefaultTypeInternal _BlockChainPayload_default_instance_;
class T2TCandidate;
class T2TCandidateDefaultTypeInternal;
extern T2TCandidateDefaultTypeInternal _T2TCandidate_default_instance_;
class T2TCandidateList;
class T2TCandidateListDefaultTypeInternal;
extern T2TCandidateListDefaultTypeInternal _T2TCandidateList_default_instance_;
class T2TCandidateListRequest;
class T2TCandidateListRequestDefaultTypeInternal;
extern T2TCandidateListRequestDefaultTypeInternal _T2TCandidateListRequest_default_instance_;
class T2TDatagram;
class T2TDatagramDefaultTypeInternal;
extern T2TDatagramDefaultTypeInternal _T2TDatagram_default_instance_;
class T2TNodeCapability;
class T2TNodeCapabilityDefaultTypeInternal;
extern T2TNodeCapabilityDefaultTypeInternal _T2TNodeCapability_default_instance_;
}  // namespace TurtleToTurtle
namespace google {
namespace protobuf {
template<> ::TurtleToTurtle::BlockChainPayload* Arena::CreateMaybeMessage<::TurtleToTurtle::BlockChainPayload>(Arena*);
template<> ::TurtleToTurtle::T2TCandidate* Arena::CreateMaybeMessage<::TurtleToTurtle::T2TCandidate>(Arena*);
template<> ::TurtleToTurtle::T2TCandidateList* Arena::CreateMaybeMessage<::TurtleToTurtle::T2TCandidateList>(Arena*);
template<> ::TurtleToTurtle::T2TCandidateListRequest* Arena::CreateMaybeMessage<::TurtleToTurtle::T2TCandidateListRequest>(Arena*);
template<> ::TurtleToTurtle::T2TDatagram* Arena::CreateMaybeMessage<::TurtleToTurtle::T2TDatagram>(Arena*);
template<> ::TurtleToTurtle::T2TNodeCapability* Arena::CreateMaybeMessage<::TurtleToTurtle::T2TNodeCapability>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace TurtleToTurtle {

// ===================================================================

class T2TDatagram : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TurtleToTurtle.T2TDatagram) */ {
 public:
  T2TDatagram();
  virtual ~T2TDatagram();

  T2TDatagram(const T2TDatagram& from);

  inline T2TDatagram& operator=(const T2TDatagram& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  T2TDatagram(T2TDatagram&& from) noexcept
    : T2TDatagram() {
    *this = ::std::move(from);
  }

  inline T2TDatagram& operator=(T2TDatagram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const T2TDatagram& default_instance();

  enum DataPayloadCase {
    kT2TCandidateList = 4,
    kT2TCandidateListRequest = 5,
    kBlockChainPayload = 6,
    DATAPAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const T2TDatagram* internal_default_instance() {
    return reinterpret_cast<const T2TDatagram*>(
               &_T2TDatagram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(T2TDatagram* other);
  friend void swap(T2TDatagram& a, T2TDatagram& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline T2TDatagram* New() const final {
    return CreateMaybeMessage<T2TDatagram>(NULL);
  }

  T2TDatagram* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<T2TDatagram>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const T2TDatagram& from);
  void MergeFrom(const T2TDatagram& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(T2TDatagram* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string peerId = 3;
  void clear_peerid();
  static const int kPeerIdFieldNumber = 3;
  const ::std::string& peerid() const;
  void set_peerid(const ::std::string& value);
  #if LANG_CXX11
  void set_peerid(::std::string&& value);
  #endif
  void set_peerid(const char* value);
  void set_peerid(const char* value, size_t size);
  ::std::string* mutable_peerid();
  ::std::string* release_peerid();
  void set_allocated_peerid(::std::string* peerid);

  // uint32 p2pNetworkId = 1;
  void clear_p2pnetworkid();
  static const int kP2PNetworkIdFieldNumber = 1;
  ::google::protobuf::uint32 p2pnetworkid() const;
  void set_p2pnetworkid(::google::protobuf::uint32 value);

  // uint32 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // .TurtleToTurtle.T2TCandidateList t2tCandidateList = 4;
  bool has_t2tcandidatelist() const;
  void clear_t2tcandidatelist();
  static const int kT2TCandidateListFieldNumber = 4;
  private:
  const ::TurtleToTurtle::T2TCandidateList& _internal_t2tcandidatelist() const;
  public:
  const ::TurtleToTurtle::T2TCandidateList& t2tcandidatelist() const;
  ::TurtleToTurtle::T2TCandidateList* release_t2tcandidatelist();
  ::TurtleToTurtle::T2TCandidateList* mutable_t2tcandidatelist();
  void set_allocated_t2tcandidatelist(::TurtleToTurtle::T2TCandidateList* t2tcandidatelist);

  // .TurtleToTurtle.T2TCandidateListRequest t2tCandidateListRequest = 5;
  bool has_t2tcandidatelistrequest() const;
  void clear_t2tcandidatelistrequest();
  static const int kT2TCandidateListRequestFieldNumber = 5;
  private:
  const ::TurtleToTurtle::T2TCandidateListRequest& _internal_t2tcandidatelistrequest() const;
  public:
  const ::TurtleToTurtle::T2TCandidateListRequest& t2tcandidatelistrequest() const;
  ::TurtleToTurtle::T2TCandidateListRequest* release_t2tcandidatelistrequest();
  ::TurtleToTurtle::T2TCandidateListRequest* mutable_t2tcandidatelistrequest();
  void set_allocated_t2tcandidatelistrequest(::TurtleToTurtle::T2TCandidateListRequest* t2tcandidatelistrequest);

  // .TurtleToTurtle.BlockChainPayload blockChainPayload = 6;
  bool has_blockchainpayload() const;
  void clear_blockchainpayload();
  static const int kBlockChainPayloadFieldNumber = 6;
  private:
  const ::TurtleToTurtle::BlockChainPayload& _internal_blockchainpayload() const;
  public:
  const ::TurtleToTurtle::BlockChainPayload& blockchainpayload() const;
  ::TurtleToTurtle::BlockChainPayload* release_blockchainpayload();
  ::TurtleToTurtle::BlockChainPayload* mutable_blockchainpayload();
  void set_allocated_blockchainpayload(::TurtleToTurtle::BlockChainPayload* blockchainpayload);

  void clear_dataPayload();
  DataPayloadCase dataPayload_case() const;
  // @@protoc_insertion_point(class_scope:TurtleToTurtle.T2TDatagram)
 private:
  void set_has_t2tcandidatelist();
  void set_has_t2tcandidatelistrequest();
  void set_has_blockchainpayload();

  inline bool has_dataPayload() const;
  inline void clear_has_dataPayload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr peerid_;
  ::google::protobuf::uint32 p2pnetworkid_;
  ::google::protobuf::uint32 version_;
  union DataPayloadUnion {
    DataPayloadUnion() {}
    ::TurtleToTurtle::T2TCandidateList* t2tcandidatelist_;
    ::TurtleToTurtle::T2TCandidateListRequest* t2tcandidatelistrequest_;
    ::TurtleToTurtle::BlockChainPayload* blockchainpayload_;
  } dataPayload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_TurtleToTurtle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class T2TCandidateList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TurtleToTurtle.T2TCandidateList) */ {
 public:
  T2TCandidateList();
  virtual ~T2TCandidateList();

  T2TCandidateList(const T2TCandidateList& from);

  inline T2TCandidateList& operator=(const T2TCandidateList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  T2TCandidateList(T2TCandidateList&& from) noexcept
    : T2TCandidateList() {
    *this = ::std::move(from);
  }

  inline T2TCandidateList& operator=(T2TCandidateList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const T2TCandidateList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const T2TCandidateList* internal_default_instance() {
    return reinterpret_cast<const T2TCandidateList*>(
               &_T2TCandidateList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(T2TCandidateList* other);
  friend void swap(T2TCandidateList& a, T2TCandidateList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline T2TCandidateList* New() const final {
    return CreateMaybeMessage<T2TCandidateList>(NULL);
  }

  T2TCandidateList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<T2TCandidateList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const T2TCandidateList& from);
  void MergeFrom(const T2TCandidateList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(T2TCandidateList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TurtleToTurtle.T2TCandidate candidate = 1;
  int candidate_size() const;
  void clear_candidate();
  static const int kCandidateFieldNumber = 1;
  ::TurtleToTurtle::T2TCandidate* mutable_candidate(int index);
  ::google::protobuf::RepeatedPtrField< ::TurtleToTurtle::T2TCandidate >*
      mutable_candidate();
  const ::TurtleToTurtle::T2TCandidate& candidate(int index) const;
  ::TurtleToTurtle::T2TCandidate* add_candidate();
  const ::google::protobuf::RepeatedPtrField< ::TurtleToTurtle::T2TCandidate >&
      candidate() const;

  // @@protoc_insertion_point(class_scope:TurtleToTurtle.T2TCandidateList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::TurtleToTurtle::T2TCandidate > candidate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TurtleToTurtle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class T2TCandidateListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TurtleToTurtle.T2TCandidateListRequest) */ {
 public:
  T2TCandidateListRequest();
  virtual ~T2TCandidateListRequest();

  T2TCandidateListRequest(const T2TCandidateListRequest& from);

  inline T2TCandidateListRequest& operator=(const T2TCandidateListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  T2TCandidateListRequest(T2TCandidateListRequest&& from) noexcept
    : T2TCandidateListRequest() {
    *this = ::std::move(from);
  }

  inline T2TCandidateListRequest& operator=(T2TCandidateListRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const T2TCandidateListRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const T2TCandidateListRequest* internal_default_instance() {
    return reinterpret_cast<const T2TCandidateListRequest*>(
               &_T2TCandidateListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(T2TCandidateListRequest* other);
  friend void swap(T2TCandidateListRequest& a, T2TCandidateListRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline T2TCandidateListRequest* New() const final {
    return CreateMaybeMessage<T2TCandidateListRequest>(NULL);
  }

  T2TCandidateListRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<T2TCandidateListRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const T2TCandidateListRequest& from);
  void MergeFrom(const T2TCandidateListRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(T2TCandidateListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 blockChainId = 1;
  int blockchainid_size() const;
  void clear_blockchainid();
  static const int kBlockChainIdFieldNumber = 1;
  ::google::protobuf::uint32 blockchainid(int index) const;
  void set_blockchainid(int index, ::google::protobuf::uint32 value);
  void add_blockchainid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      blockchainid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_blockchainid();

  // @@protoc_insertion_point(class_scope:TurtleToTurtle.T2TCandidateListRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > blockchainid_;
  mutable int _blockchainid_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TurtleToTurtle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class T2TCandidate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TurtleToTurtle.T2TCandidate) */ {
 public:
  T2TCandidate();
  virtual ~T2TCandidate();

  T2TCandidate(const T2TCandidate& from);

  inline T2TCandidate& operator=(const T2TCandidate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  T2TCandidate(T2TCandidate&& from) noexcept
    : T2TCandidate() {
    *this = ::std::move(from);
  }

  inline T2TCandidate& operator=(T2TCandidate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const T2TCandidate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const T2TCandidate* internal_default_instance() {
    return reinterpret_cast<const T2TCandidate*>(
               &_T2TCandidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(T2TCandidate* other);
  friend void swap(T2TCandidate& a, T2TCandidate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline T2TCandidate* New() const final {
    return CreateMaybeMessage<T2TCandidate>(NULL);
  }

  T2TCandidate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<T2TCandidate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const T2TCandidate& from);
  void MergeFrom(const T2TCandidate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(T2TCandidate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string peerId = 1;
  void clear_peerid();
  static const int kPeerIdFieldNumber = 1;
  const ::std::string& peerid() const;
  void set_peerid(const ::std::string& value);
  #if LANG_CXX11
  void set_peerid(::std::string&& value);
  #endif
  void set_peerid(const char* value);
  void set_peerid(const char* value, size_t size);
  ::std::string* mutable_peerid();
  ::std::string* release_peerid();
  void set_allocated_peerid(::std::string* peerid);

  // string ipV6Address = 4;
  void clear_ipv6address();
  static const int kIpV6AddressFieldNumber = 4;
  const ::std::string& ipv6address() const;
  void set_ipv6address(const ::std::string& value);
  #if LANG_CXX11
  void set_ipv6address(::std::string&& value);
  #endif
  void set_ipv6address(const char* value);
  void set_ipv6address(const char* value, size_t size);
  ::std::string* mutable_ipv6address();
  ::std::string* release_ipv6address();
  void set_allocated_ipv6address(::std::string* ipv6address);

  // .TurtleToTurtle.T2TNodeCapability capability = 7;
  bool has_capability() const;
  void clear_capability();
  static const int kCapabilityFieldNumber = 7;
  private:
  const ::TurtleToTurtle::T2TNodeCapability& _internal_capability() const;
  public:
  const ::TurtleToTurtle::T2TNodeCapability& capability() const;
  ::TurtleToTurtle::T2TNodeCapability* release_capability();
  ::TurtleToTurtle::T2TNodeCapability* mutable_capability();
  void set_allocated_capability(::TurtleToTurtle::T2TNodeCapability* capability);

  // uint32 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // uint32 ipV4Address = 3;
  void clear_ipv4address();
  static const int kIpV4AddressFieldNumber = 3;
  ::google::protobuf::uint32 ipv4address() const;
  void set_ipv4address(::google::protobuf::uint32 value);

  // uint32 port = 5;
  void clear_port();
  static const int kPortFieldNumber = 5;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // uint32 ttl = 6;
  void clear_ttl();
  static const int kTtlFieldNumber = 6;
  ::google::protobuf::uint32 ttl() const;
  void set_ttl(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TurtleToTurtle.T2TCandidate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr peerid_;
  ::google::protobuf::internal::ArenaStringPtr ipv6address_;
  ::TurtleToTurtle::T2TNodeCapability* capability_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 ipv4address_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 ttl_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TurtleToTurtle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class T2TNodeCapability : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TurtleToTurtle.T2TNodeCapability) */ {
 public:
  T2TNodeCapability();
  virtual ~T2TNodeCapability();

  T2TNodeCapability(const T2TNodeCapability& from);

  inline T2TNodeCapability& operator=(const T2TNodeCapability& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  T2TNodeCapability(T2TNodeCapability&& from) noexcept
    : T2TNodeCapability() {
    *this = ::std::move(from);
  }

  inline T2TNodeCapability& operator=(T2TNodeCapability&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const T2TNodeCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const T2TNodeCapability* internal_default_instance() {
    return reinterpret_cast<const T2TNodeCapability*>(
               &_T2TNodeCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(T2TNodeCapability* other);
  friend void swap(T2TNodeCapability& a, T2TNodeCapability& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline T2TNodeCapability* New() const final {
    return CreateMaybeMessage<T2TNodeCapability>(NULL);
  }

  T2TNodeCapability* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<T2TNodeCapability>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const T2TNodeCapability& from);
  void MergeFrom(const T2TNodeCapability& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(T2TNodeCapability* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 blockChainId = 2;
  int blockchainid_size() const;
  void clear_blockchainid();
  static const int kBlockChainIdFieldNumber = 2;
  ::google::protobuf::uint32 blockchainid(int index) const;
  void set_blockchainid(int index, ::google::protobuf::uint32 value);
  void add_blockchainid(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      blockchainid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_blockchainid();

  // bool archival = 1;
  void clear_archival();
  static const int kArchivalFieldNumber = 1;
  bool archival() const;
  void set_archival(bool value);

  // @@protoc_insertion_point(class_scope:TurtleToTurtle.T2TNodeCapability)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > blockchainid_;
  mutable int _blockchainid_cached_byte_size_;
  bool archival_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_TurtleToTurtle_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockChainPayload : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TurtleToTurtle.BlockChainPayload) */ {
 public:
  BlockChainPayload();
  virtual ~BlockChainPayload();

  BlockChainPayload(const BlockChainPayload& from);

  inline BlockChainPayload& operator=(const BlockChainPayload& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockChainPayload(BlockChainPayload&& from) noexcept
    : BlockChainPayload() {
    *this = ::std::move(from);
  }

  inline BlockChainPayload& operator=(BlockChainPayload&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockChainPayload& default_instance();

  enum DataCase {
    kBlock = 1,
    kTransaction = 2,
    DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockChainPayload* internal_default_instance() {
    return reinterpret_cast<const BlockChainPayload*>(
               &_BlockChainPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(BlockChainPayload* other);
  friend void swap(BlockChainPayload& a, BlockChainPayload& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockChainPayload* New() const final {
    return CreateMaybeMessage<BlockChainPayload>(NULL);
  }

  BlockChainPayload* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockChainPayload>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockChainPayload& from);
  void MergeFrom(const BlockChainPayload& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockChainPayload* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TurtleToTurtle.TurtleCoin.TurtleBlock block = 1;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  private:
  const ::TurtleToTurtle::TurtleCoin::TurtleBlock& _internal_block() const;
  public:
  const ::TurtleToTurtle::TurtleCoin::TurtleBlock& block() const;
  ::TurtleToTurtle::TurtleCoin::TurtleBlock* release_block();
  ::TurtleToTurtle::TurtleCoin::TurtleBlock* mutable_block();
  void set_allocated_block(::TurtleToTurtle::TurtleCoin::TurtleBlock* block);

  // .TurtleToTurtle.TurtleCoin.TurtleTransaction transaction = 2;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 2;
  private:
  const ::TurtleToTurtle::TurtleCoin::TurtleTransaction& _internal_transaction() const;
  public:
  const ::TurtleToTurtle::TurtleCoin::TurtleTransaction& transaction() const;
  ::TurtleToTurtle::TurtleCoin::TurtleTransaction* release_transaction();
  ::TurtleToTurtle::TurtleCoin::TurtleTransaction* mutable_transaction();
  void set_allocated_transaction(::TurtleToTurtle::TurtleCoin::TurtleTransaction* transaction);

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:TurtleToTurtle.BlockChainPayload)
 private:
  void set_has_block();
  void set_has_transaction();

  inline bool has_data() const;
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union DataUnion {
    DataUnion() {}
    ::TurtleToTurtle::TurtleCoin::TurtleBlock* block_;
    ::TurtleToTurtle::TurtleCoin::TurtleTransaction* transaction_;
  } data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_TurtleToTurtle_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// T2TDatagram

// uint32 p2pNetworkId = 1;
inline void T2TDatagram::clear_p2pnetworkid() {
  p2pnetworkid_ = 0u;
}
inline ::google::protobuf::uint32 T2TDatagram::p2pnetworkid() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TDatagram.p2pNetworkId)
  return p2pnetworkid_;
}
inline void T2TDatagram::set_p2pnetworkid(::google::protobuf::uint32 value) {
  
  p2pnetworkid_ = value;
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TDatagram.p2pNetworkId)
}

// uint32 version = 2;
inline void T2TDatagram::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 T2TDatagram::version() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TDatagram.version)
  return version_;
}
inline void T2TDatagram::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TDatagram.version)
}

// string peerId = 3;
inline void T2TDatagram::clear_peerid() {
  peerid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& T2TDatagram::peerid() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TDatagram.peerId)
  return peerid_.GetNoArena();
}
inline void T2TDatagram::set_peerid(const ::std::string& value) {
  
  peerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TDatagram.peerId)
}
#if LANG_CXX11
inline void T2TDatagram::set_peerid(::std::string&& value) {
  
  peerid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TurtleToTurtle.T2TDatagram.peerId)
}
#endif
inline void T2TDatagram::set_peerid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  peerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TurtleToTurtle.T2TDatagram.peerId)
}
inline void T2TDatagram::set_peerid(const char* value, size_t size) {
  
  peerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TurtleToTurtle.T2TDatagram.peerId)
}
inline ::std::string* T2TDatagram::mutable_peerid() {
  
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TDatagram.peerId)
  return peerid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* T2TDatagram::release_peerid() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.T2TDatagram.peerId)
  
  return peerid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void T2TDatagram::set_allocated_peerid(::std::string* peerid) {
  if (peerid != NULL) {
    
  } else {
    
  }
  peerid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peerid);
  // @@protoc_insertion_point(field_set_allocated:TurtleToTurtle.T2TDatagram.peerId)
}

// .TurtleToTurtle.T2TCandidateList t2tCandidateList = 4;
inline bool T2TDatagram::has_t2tcandidatelist() const {
  return dataPayload_case() == kT2TCandidateList;
}
inline void T2TDatagram::set_has_t2tcandidatelist() {
  _oneof_case_[0] = kT2TCandidateList;
}
inline void T2TDatagram::clear_t2tcandidatelist() {
  if (has_t2tcandidatelist()) {
    delete dataPayload_.t2tcandidatelist_;
    clear_has_dataPayload();
  }
}
inline const ::TurtleToTurtle::T2TCandidateList& T2TDatagram::_internal_t2tcandidatelist() const {
  return *dataPayload_.t2tcandidatelist_;
}
inline ::TurtleToTurtle::T2TCandidateList* T2TDatagram::release_t2tcandidatelist() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.T2TDatagram.t2tCandidateList)
  if (has_t2tcandidatelist()) {
    clear_has_dataPayload();
      ::TurtleToTurtle::T2TCandidateList* temp = dataPayload_.t2tcandidatelist_;
    dataPayload_.t2tcandidatelist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TurtleToTurtle::T2TCandidateList& T2TDatagram::t2tcandidatelist() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TDatagram.t2tCandidateList)
  return has_t2tcandidatelist()
      ? *dataPayload_.t2tcandidatelist_
      : *reinterpret_cast< ::TurtleToTurtle::T2TCandidateList*>(&::TurtleToTurtle::_T2TCandidateList_default_instance_);
}
inline ::TurtleToTurtle::T2TCandidateList* T2TDatagram::mutable_t2tcandidatelist() {
  if (!has_t2tcandidatelist()) {
    clear_dataPayload();
    set_has_t2tcandidatelist();
    dataPayload_.t2tcandidatelist_ = CreateMaybeMessage< ::TurtleToTurtle::T2TCandidateList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TDatagram.t2tCandidateList)
  return dataPayload_.t2tcandidatelist_;
}

// .TurtleToTurtle.T2TCandidateListRequest t2tCandidateListRequest = 5;
inline bool T2TDatagram::has_t2tcandidatelistrequest() const {
  return dataPayload_case() == kT2TCandidateListRequest;
}
inline void T2TDatagram::set_has_t2tcandidatelistrequest() {
  _oneof_case_[0] = kT2TCandidateListRequest;
}
inline void T2TDatagram::clear_t2tcandidatelistrequest() {
  if (has_t2tcandidatelistrequest()) {
    delete dataPayload_.t2tcandidatelistrequest_;
    clear_has_dataPayload();
  }
}
inline const ::TurtleToTurtle::T2TCandidateListRequest& T2TDatagram::_internal_t2tcandidatelistrequest() const {
  return *dataPayload_.t2tcandidatelistrequest_;
}
inline ::TurtleToTurtle::T2TCandidateListRequest* T2TDatagram::release_t2tcandidatelistrequest() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.T2TDatagram.t2tCandidateListRequest)
  if (has_t2tcandidatelistrequest()) {
    clear_has_dataPayload();
      ::TurtleToTurtle::T2TCandidateListRequest* temp = dataPayload_.t2tcandidatelistrequest_;
    dataPayload_.t2tcandidatelistrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TurtleToTurtle::T2TCandidateListRequest& T2TDatagram::t2tcandidatelistrequest() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TDatagram.t2tCandidateListRequest)
  return has_t2tcandidatelistrequest()
      ? *dataPayload_.t2tcandidatelistrequest_
      : *reinterpret_cast< ::TurtleToTurtle::T2TCandidateListRequest*>(&::TurtleToTurtle::_T2TCandidateListRequest_default_instance_);
}
inline ::TurtleToTurtle::T2TCandidateListRequest* T2TDatagram::mutable_t2tcandidatelistrequest() {
  if (!has_t2tcandidatelistrequest()) {
    clear_dataPayload();
    set_has_t2tcandidatelistrequest();
    dataPayload_.t2tcandidatelistrequest_ = CreateMaybeMessage< ::TurtleToTurtle::T2TCandidateListRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TDatagram.t2tCandidateListRequest)
  return dataPayload_.t2tcandidatelistrequest_;
}

// .TurtleToTurtle.BlockChainPayload blockChainPayload = 6;
inline bool T2TDatagram::has_blockchainpayload() const {
  return dataPayload_case() == kBlockChainPayload;
}
inline void T2TDatagram::set_has_blockchainpayload() {
  _oneof_case_[0] = kBlockChainPayload;
}
inline void T2TDatagram::clear_blockchainpayload() {
  if (has_blockchainpayload()) {
    delete dataPayload_.blockchainpayload_;
    clear_has_dataPayload();
  }
}
inline const ::TurtleToTurtle::BlockChainPayload& T2TDatagram::_internal_blockchainpayload() const {
  return *dataPayload_.blockchainpayload_;
}
inline ::TurtleToTurtle::BlockChainPayload* T2TDatagram::release_blockchainpayload() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.T2TDatagram.blockChainPayload)
  if (has_blockchainpayload()) {
    clear_has_dataPayload();
      ::TurtleToTurtle::BlockChainPayload* temp = dataPayload_.blockchainpayload_;
    dataPayload_.blockchainpayload_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TurtleToTurtle::BlockChainPayload& T2TDatagram::blockchainpayload() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TDatagram.blockChainPayload)
  return has_blockchainpayload()
      ? *dataPayload_.blockchainpayload_
      : *reinterpret_cast< ::TurtleToTurtle::BlockChainPayload*>(&::TurtleToTurtle::_BlockChainPayload_default_instance_);
}
inline ::TurtleToTurtle::BlockChainPayload* T2TDatagram::mutable_blockchainpayload() {
  if (!has_blockchainpayload()) {
    clear_dataPayload();
    set_has_blockchainpayload();
    dataPayload_.blockchainpayload_ = CreateMaybeMessage< ::TurtleToTurtle::BlockChainPayload >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TDatagram.blockChainPayload)
  return dataPayload_.blockchainpayload_;
}

inline bool T2TDatagram::has_dataPayload() const {
  return dataPayload_case() != DATAPAYLOAD_NOT_SET;
}
inline void T2TDatagram::clear_has_dataPayload() {
  _oneof_case_[0] = DATAPAYLOAD_NOT_SET;
}
inline T2TDatagram::DataPayloadCase T2TDatagram::dataPayload_case() const {
  return T2TDatagram::DataPayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// T2TCandidateList

// repeated .TurtleToTurtle.T2TCandidate candidate = 1;
inline int T2TCandidateList::candidate_size() const {
  return candidate_.size();
}
inline void T2TCandidateList::clear_candidate() {
  candidate_.Clear();
}
inline ::TurtleToTurtle::T2TCandidate* T2TCandidateList::mutable_candidate(int index) {
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TCandidateList.candidate)
  return candidate_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::TurtleToTurtle::T2TCandidate >*
T2TCandidateList::mutable_candidate() {
  // @@protoc_insertion_point(field_mutable_list:TurtleToTurtle.T2TCandidateList.candidate)
  return &candidate_;
}
inline const ::TurtleToTurtle::T2TCandidate& T2TCandidateList::candidate(int index) const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidateList.candidate)
  return candidate_.Get(index);
}
inline ::TurtleToTurtle::T2TCandidate* T2TCandidateList::add_candidate() {
  // @@protoc_insertion_point(field_add:TurtleToTurtle.T2TCandidateList.candidate)
  return candidate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TurtleToTurtle::T2TCandidate >&
T2TCandidateList::candidate() const {
  // @@protoc_insertion_point(field_list:TurtleToTurtle.T2TCandidateList.candidate)
  return candidate_;
}

// -------------------------------------------------------------------

// T2TCandidateListRequest

// repeated uint32 blockChainId = 1;
inline int T2TCandidateListRequest::blockchainid_size() const {
  return blockchainid_.size();
}
inline void T2TCandidateListRequest::clear_blockchainid() {
  blockchainid_.Clear();
}
inline ::google::protobuf::uint32 T2TCandidateListRequest::blockchainid(int index) const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidateListRequest.blockChainId)
  return blockchainid_.Get(index);
}
inline void T2TCandidateListRequest::set_blockchainid(int index, ::google::protobuf::uint32 value) {
  blockchainid_.Set(index, value);
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TCandidateListRequest.blockChainId)
}
inline void T2TCandidateListRequest::add_blockchainid(::google::protobuf::uint32 value) {
  blockchainid_.Add(value);
  // @@protoc_insertion_point(field_add:TurtleToTurtle.T2TCandidateListRequest.blockChainId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
T2TCandidateListRequest::blockchainid() const {
  // @@protoc_insertion_point(field_list:TurtleToTurtle.T2TCandidateListRequest.blockChainId)
  return blockchainid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
T2TCandidateListRequest::mutable_blockchainid() {
  // @@protoc_insertion_point(field_mutable_list:TurtleToTurtle.T2TCandidateListRequest.blockChainId)
  return &blockchainid_;
}

// -------------------------------------------------------------------

// T2TCandidate

// string peerId = 1;
inline void T2TCandidate::clear_peerid() {
  peerid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& T2TCandidate::peerid() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidate.peerId)
  return peerid_.GetNoArena();
}
inline void T2TCandidate::set_peerid(const ::std::string& value) {
  
  peerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TCandidate.peerId)
}
#if LANG_CXX11
inline void T2TCandidate::set_peerid(::std::string&& value) {
  
  peerid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TurtleToTurtle.T2TCandidate.peerId)
}
#endif
inline void T2TCandidate::set_peerid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  peerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TurtleToTurtle.T2TCandidate.peerId)
}
inline void T2TCandidate::set_peerid(const char* value, size_t size) {
  
  peerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TurtleToTurtle.T2TCandidate.peerId)
}
inline ::std::string* T2TCandidate::mutable_peerid() {
  
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TCandidate.peerId)
  return peerid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* T2TCandidate::release_peerid() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.T2TCandidate.peerId)
  
  return peerid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void T2TCandidate::set_allocated_peerid(::std::string* peerid) {
  if (peerid != NULL) {
    
  } else {
    
  }
  peerid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peerid);
  // @@protoc_insertion_point(field_set_allocated:TurtleToTurtle.T2TCandidate.peerId)
}

// uint32 version = 2;
inline void T2TCandidate::clear_version() {
  version_ = 0u;
}
inline ::google::protobuf::uint32 T2TCandidate::version() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidate.version)
  return version_;
}
inline void T2TCandidate::set_version(::google::protobuf::uint32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TCandidate.version)
}

// uint32 ipV4Address = 3;
inline void T2TCandidate::clear_ipv4address() {
  ipv4address_ = 0u;
}
inline ::google::protobuf::uint32 T2TCandidate::ipv4address() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidate.ipV4Address)
  return ipv4address_;
}
inline void T2TCandidate::set_ipv4address(::google::protobuf::uint32 value) {
  
  ipv4address_ = value;
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TCandidate.ipV4Address)
}

// string ipV6Address = 4;
inline void T2TCandidate::clear_ipv6address() {
  ipv6address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& T2TCandidate::ipv6address() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidate.ipV6Address)
  return ipv6address_.GetNoArena();
}
inline void T2TCandidate::set_ipv6address(const ::std::string& value) {
  
  ipv6address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TCandidate.ipV6Address)
}
#if LANG_CXX11
inline void T2TCandidate::set_ipv6address(::std::string&& value) {
  
  ipv6address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TurtleToTurtle.T2TCandidate.ipV6Address)
}
#endif
inline void T2TCandidate::set_ipv6address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ipv6address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TurtleToTurtle.T2TCandidate.ipV6Address)
}
inline void T2TCandidate::set_ipv6address(const char* value, size_t size) {
  
  ipv6address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TurtleToTurtle.T2TCandidate.ipV6Address)
}
inline ::std::string* T2TCandidate::mutable_ipv6address() {
  
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TCandidate.ipV6Address)
  return ipv6address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* T2TCandidate::release_ipv6address() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.T2TCandidate.ipV6Address)
  
  return ipv6address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void T2TCandidate::set_allocated_ipv6address(::std::string* ipv6address) {
  if (ipv6address != NULL) {
    
  } else {
    
  }
  ipv6address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ipv6address);
  // @@protoc_insertion_point(field_set_allocated:TurtleToTurtle.T2TCandidate.ipV6Address)
}

// uint32 port = 5;
inline void T2TCandidate::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 T2TCandidate::port() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidate.port)
  return port_;
}
inline void T2TCandidate::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TCandidate.port)
}

// uint32 ttl = 6;
inline void T2TCandidate::clear_ttl() {
  ttl_ = 0u;
}
inline ::google::protobuf::uint32 T2TCandidate::ttl() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidate.ttl)
  return ttl_;
}
inline void T2TCandidate::set_ttl(::google::protobuf::uint32 value) {
  
  ttl_ = value;
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TCandidate.ttl)
}

// .TurtleToTurtle.T2TNodeCapability capability = 7;
inline bool T2TCandidate::has_capability() const {
  return this != internal_default_instance() && capability_ != NULL;
}
inline void T2TCandidate::clear_capability() {
  if (GetArenaNoVirtual() == NULL && capability_ != NULL) {
    delete capability_;
  }
  capability_ = NULL;
}
inline const ::TurtleToTurtle::T2TNodeCapability& T2TCandidate::_internal_capability() const {
  return *capability_;
}
inline const ::TurtleToTurtle::T2TNodeCapability& T2TCandidate::capability() const {
  const ::TurtleToTurtle::T2TNodeCapability* p = capability_;
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TCandidate.capability)
  return p != NULL ? *p : *reinterpret_cast<const ::TurtleToTurtle::T2TNodeCapability*>(
      &::TurtleToTurtle::_T2TNodeCapability_default_instance_);
}
inline ::TurtleToTurtle::T2TNodeCapability* T2TCandidate::release_capability() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.T2TCandidate.capability)
  
  ::TurtleToTurtle::T2TNodeCapability* temp = capability_;
  capability_ = NULL;
  return temp;
}
inline ::TurtleToTurtle::T2TNodeCapability* T2TCandidate::mutable_capability() {
  
  if (capability_ == NULL) {
    auto* p = CreateMaybeMessage<::TurtleToTurtle::T2TNodeCapability>(GetArenaNoVirtual());
    capability_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.T2TCandidate.capability)
  return capability_;
}
inline void T2TCandidate::set_allocated_capability(::TurtleToTurtle::T2TNodeCapability* capability) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete capability_;
  }
  if (capability) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      capability = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, capability, submessage_arena);
    }
    
  } else {
    
  }
  capability_ = capability;
  // @@protoc_insertion_point(field_set_allocated:TurtleToTurtle.T2TCandidate.capability)
}

// -------------------------------------------------------------------

// T2TNodeCapability

// bool archival = 1;
inline void T2TNodeCapability::clear_archival() {
  archival_ = false;
}
inline bool T2TNodeCapability::archival() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TNodeCapability.archival)
  return archival_;
}
inline void T2TNodeCapability::set_archival(bool value) {
  
  archival_ = value;
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TNodeCapability.archival)
}

// repeated uint32 blockChainId = 2;
inline int T2TNodeCapability::blockchainid_size() const {
  return blockchainid_.size();
}
inline void T2TNodeCapability::clear_blockchainid() {
  blockchainid_.Clear();
}
inline ::google::protobuf::uint32 T2TNodeCapability::blockchainid(int index) const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.T2TNodeCapability.blockChainId)
  return blockchainid_.Get(index);
}
inline void T2TNodeCapability::set_blockchainid(int index, ::google::protobuf::uint32 value) {
  blockchainid_.Set(index, value);
  // @@protoc_insertion_point(field_set:TurtleToTurtle.T2TNodeCapability.blockChainId)
}
inline void T2TNodeCapability::add_blockchainid(::google::protobuf::uint32 value) {
  blockchainid_.Add(value);
  // @@protoc_insertion_point(field_add:TurtleToTurtle.T2TNodeCapability.blockChainId)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
T2TNodeCapability::blockchainid() const {
  // @@protoc_insertion_point(field_list:TurtleToTurtle.T2TNodeCapability.blockChainId)
  return blockchainid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
T2TNodeCapability::mutable_blockchainid() {
  // @@protoc_insertion_point(field_mutable_list:TurtleToTurtle.T2TNodeCapability.blockChainId)
  return &blockchainid_;
}

// -------------------------------------------------------------------

// BlockChainPayload

// .TurtleToTurtle.TurtleCoin.TurtleBlock block = 1;
inline bool BlockChainPayload::has_block() const {
  return data_case() == kBlock;
}
inline void BlockChainPayload::set_has_block() {
  _oneof_case_[0] = kBlock;
}
inline const ::TurtleToTurtle::TurtleCoin::TurtleBlock& BlockChainPayload::_internal_block() const {
  return *data_.block_;
}
inline ::TurtleToTurtle::TurtleCoin::TurtleBlock* BlockChainPayload::release_block() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.BlockChainPayload.block)
  if (has_block()) {
    clear_has_data();
      ::TurtleToTurtle::TurtleCoin::TurtleBlock* temp = data_.block_;
    data_.block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TurtleToTurtle::TurtleCoin::TurtleBlock& BlockChainPayload::block() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.BlockChainPayload.block)
  return has_block()
      ? *data_.block_
      : *reinterpret_cast< ::TurtleToTurtle::TurtleCoin::TurtleBlock*>(&::TurtleToTurtle::TurtleCoin::_TurtleBlock_default_instance_);
}
inline ::TurtleToTurtle::TurtleCoin::TurtleBlock* BlockChainPayload::mutable_block() {
  if (!has_block()) {
    clear_data();
    set_has_block();
    data_.block_ = CreateMaybeMessage< ::TurtleToTurtle::TurtleCoin::TurtleBlock >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.BlockChainPayload.block)
  return data_.block_;
}

// .TurtleToTurtle.TurtleCoin.TurtleTransaction transaction = 2;
inline bool BlockChainPayload::has_transaction() const {
  return data_case() == kTransaction;
}
inline void BlockChainPayload::set_has_transaction() {
  _oneof_case_[0] = kTransaction;
}
inline const ::TurtleToTurtle::TurtleCoin::TurtleTransaction& BlockChainPayload::_internal_transaction() const {
  return *data_.transaction_;
}
inline ::TurtleToTurtle::TurtleCoin::TurtleTransaction* BlockChainPayload::release_transaction() {
  // @@protoc_insertion_point(field_release:TurtleToTurtle.BlockChainPayload.transaction)
  if (has_transaction()) {
    clear_has_data();
      ::TurtleToTurtle::TurtleCoin::TurtleTransaction* temp = data_.transaction_;
    data_.transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::TurtleToTurtle::TurtleCoin::TurtleTransaction& BlockChainPayload::transaction() const {
  // @@protoc_insertion_point(field_get:TurtleToTurtle.BlockChainPayload.transaction)
  return has_transaction()
      ? *data_.transaction_
      : *reinterpret_cast< ::TurtleToTurtle::TurtleCoin::TurtleTransaction*>(&::TurtleToTurtle::TurtleCoin::_TurtleTransaction_default_instance_);
}
inline ::TurtleToTurtle::TurtleCoin::TurtleTransaction* BlockChainPayload::mutable_transaction() {
  if (!has_transaction()) {
    clear_data();
    set_has_transaction();
    data_.transaction_ = CreateMaybeMessage< ::TurtleToTurtle::TurtleCoin::TurtleTransaction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TurtleToTurtle.BlockChainPayload.transaction)
  return data_.transaction_;
}

inline bool BlockChainPayload::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void BlockChainPayload::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline BlockChainPayload::DataCase BlockChainPayload::data_case() const {
  return BlockChainPayload::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace TurtleToTurtle

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_TurtleToTurtle_2eproto
